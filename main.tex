\input{style.tex}

\begin{document}

%%
%% begin titlepage
%%

\begin{titlepage}
\newgeometry{left=6cm}
\definecolor{titlepage-color}{HTML}{2196F3}
\newpagecolor{titlepage-color}\afterpage{\restorepagecolor}
\newcommand{\colorRule}[3][black]{\textcolor[HTML]{#1}{\rule{#2}{#3}}}
\begin{flushleft}
\noindent
\\[-1em]
\color[HTML]{FFFFFF}
\makebox[0pt][l]{\colorRule[1976D2]{1.3\textwidth}{8pt}}
\par
\noindent

{ \setstretch{1.4}
\vfill
\noindent {\huge \textbf{\textsf{The Raft Consensus Algorithm}}}
\vskip 2em
\noindent
{\Large \textsf{\MakeUppercase{Fabio Anderegg}}
\vfill
}

\textsf{2017-12-04}}
\end{flushleft}
\end{titlepage}
\restoregeometry

%%
%% end titlepage
%%


{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{3}
\tableofcontents
\pagebreak
}

\section{Introduction}

\includegraphics[scale=0.1]{raft}

This paper covers Raft, a consensus algorithm for distributed systems.

Raft wants to be a simpler replacement for PAXOS, an algorithm developed by Leslie Lamport and considered the reference consensus algorithm for distributed systems[CN]. PAXOS suffers from two big problems, which Raft tries to solve: It is very hard to understand [CN] and it has some missing pieces to actually implement a real world system using PAXOS [CN (Chubby?)].

Raft was developed by Diego Ongaro and extensivly described in this PhD thesis [CN]. He not only describes how the algorithm works, bot also describes a study under students to test if the algorithm is actually easier to understand than PAXOS. Raft has been formally verified to be correct [CN] and implemented in multiple real world systems, e.g. in etcd [CN], Consul [CN] and RethinkDB [CN].

The offical GitHub Page [https://raft.github.io/] contains many further references about the algorithm, a simulator for the algorithm from which screenshots have been used in this paper and an extensive list of implementations in many different programming languages.

This paper has four parts: The first part explains what consensus in a distributed system is and how it is used, the second part explains how the Raft algorithm works, the third part shows how Raft handles some failure modes. To validate the claim that Raft is easy to implement, the author of this paper tried to implement a simple key/value store using Raft, which is described in the fourth part.

\section{What is consensus?}

Discuss the consensus problem for distributed systems.
Consensus: getting a number of machines to agree on a specific value or outcome.

Problem: Hosts and networks can stop working, be slow or have other failures.

\section {The Raft algorithm}

Introduction...

\subsection{The CAP Theorem}

The CAP theorem describe how certain failures in a distributed system affects the system. It states that a distributed system can never provide more than two of the following guarantees:

\begin{itemize}
    \item Consistency: TODO
    \item Availability: TODO
    \item Partition tolerance: TODO
\end{itemize}

Raft is a CP algorithm, that means systems using this algorithm are tolerant to partitions and always provide consistency by sacrificing availability. 

\subsection{The algorithm}
This is the general overview what state and messages the Raft algorithm uses. Examples how these things play together are given in the next chapter.

\subsubsection{State}
current term
current index

\subsubsection{RPC}
2 Messages with 2 Answers

\subsubsection{Cheat sheet}
Like in the original raft paper, but with much more information (flow-diagram or pseudo code)


\subsection{Scenarios}
This section takes a look on different scenarios and failure modes in the cluster and how Raft handles these cases.

\subsubsection{Leader election}

\subsubsection{Heartbeat}

\subsubsection{Data write}
Writing data into the cluster uses the same message as the heartbeat.


\subsubsection{Master crash}
A master crash is handled like the initial leader election, the election timeout runs out on one of the servers, the server ...

\subsubsection{Delayed packages}
=> Wait until enough packages arrive, this is a CP algorithm after all

\subsubsection{Network partition}

\subsubsection{Old follower returns}


\subsubsection{Old master returns}
=> Steps down as soon as they see a heartbeat packet from the current master with a newer term.
The node is a follower now and does the same as in the section above to regain all the missing data.

\subsubsection{Switching masters in network partition}
When connection between two nodes fail, a ping-pong between these two nodes *can* happen.

\subsubsection{Inconsistens reads}
https://github.com/coreos/etcd/issues/741

\section {Implementation}

https://github.com/fotcorn/raft

* C++
* Boost library
* Protobuf

\end{document}
